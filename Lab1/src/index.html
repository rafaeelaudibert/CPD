<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <title>Lab 1</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.2/Chart.bundle.min.js"></script>
    <script src="chartjs-plugin-zoom.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Montserrat:100,100i,200,200i,300,300i,400,400i,500,500i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">
    <link rel="stylesheet" href="main.css">
    <link rel="stylesheet" href="highlight.css">

  </head>

  <body>
    <article>
      <div class="title">
        <div class="title-wrapper">
          <h1 class="display-4"><span>Data Search & Classification </span></h1>
        </div>
        <div class="info">
          <h3><small class="text-muted">Lab 1</small></h3>
          <h3><small class="text-muted">INF - UFRGS</small></h3>
        </div>
      </div>
      <p>This is the report/article for the first lab of the Data Search & Classification üìä Subject of the UFRGS - INF CS course üíª. We basically are talking about asymptotic complexity in general, as well as sorting algorithms, which will have some charts
        here talking about them. We will also have a playground unning with async JavaScript code, which will be emulated live on this page, through an API connected to the backend-server. You will be able to experiment some stuff (check it at the end
        of the page later).</p>
      <blockquote>
        <p>The JavaScript code will run in a separated thread, which will be requested through an API call to the Node.js backend of this server. The C data was generated with <a href="sorting.c">this</a> code, compiled with GCC version 5.1.0 which can be
          downloaded in this <a href="data.rar">zip</a> file containing the csv data used.</p>
      </blockquote>
      <figure>
        <img src="https://images.pexels.com/photos/247791/pexels-photo-247791.png?auto=compress&cs=tinysrgb&dpr=2&h=650&w=940">
      </figure>

      <h2 id="subtitle-1">Analyzing complexity time cases ‚è±Ô∏è</h2>

      <p>First, we must analyze and understand the theta asymptotic notation of some simple functions. To do so, we must find a given value n, which when applied to 2 another functions of the same complexity, will make the former to be between then, that
        is, we have a function with a higher asymptotic value and another with a lower one. We will have some charts to help us understand what is going on (I won't say it won't have math in some of them). Remember to zoom in (maybe it will look a bit
        clunky, but you can do it) to see more details, especially in those with a thight advantage only.</p>

      <!-- Complexity cards -->
      <div id="accordion">
        <div class="card">
          <div class="card-header" id="headingOne" data-toggle="collapse" data-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
            <h5 class="mb-0">
              <button class="btn btn-link collapsed">
                <div class="formula">\(50n\)</n>
              </button>
            </h5>
          </div>
          <div id="collapseOne" class="collapse" aria-labelledby="headingOne" data-parent="#accordion">
            <div class="card-body">
              This one can easily be seen in the chart below. We used 40 and 60 as an upper and a lower constant, but we could use anything just a bit higher or lower than 50 to show that this function has a complexity of \(\Theta\)(\(n\)). As you can see this complexity
              can be seen since the origin (you can check it out zooming in the chart), making our value \(n\), which is the lower threshold for the \(\Theta\) notation, to be 0.
              <canvas id="complexity1" class="chartjs" width="undefined" height="undefined"></canvas>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="card-header" id="headingTwo" data-toggle="collapse" data-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
            <h5 class="mb-0">
              <button class="btn btn-link collapsed">
                <div class="formula">\(n^2 + 2n + 10\)</n>
              </button>
            </h5>
          </div>
          <div id="collapseTwo" class="collapse" aria-labelledby="headingTwo" data-parent="#accordion">
            <div class="card-body">
              This one can also easily be proven as having a complexity of \(\Theta\)(\(n^2\)). If you zoom in closer to the x = 0, you can see how the \(n^2 + 2n + 10\) curve is higher than the \(2n^2\), but the latter overcomes it really soon, between \(x=4\) and
              \(x=5\). As you can see, the purple curve (the one which is interestig for us) is just a little bit higher than the blue one, but it will be higher than it forever, increasing its margin little by little, making our complexity to be \(\Theta\)(\(n^2\)).
              <canvas id="complexity2" class="chartjs" width="undefined" height="undefined"></canvas>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="card-header" id="headingThree" data-toggle="collapse" data-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
            <h5 class="mb-0">
              <button class="btn btn-link collapsed">
                <div class="formula">\(n + \log n \)</n>
              </button>
            </h5>
          </div>
          <div id="collapseThree" class="collapse" aria-labelledby="headingThree" data-parent="#accordion">
            <div class="card-body">
              This is a easy one. Just looking to the chart we can see it has a complexity of \(\Theta(n)\), because \(n \gg \log (n)\), so we can treat \(\log (n)\) as a constant.
              <canvas id="complexity3" class="chartjs" width="undefined" height="undefined"></canvas>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="card-header" data-toggle="collapse" data-target="#collapseFour" id="headingFour">
            <h5 class="mb-0">
              <button class="btn btn-link collapsed">
                <div class="formula">\(n^3 -100 n^2\)</div>
              </button>
            </h5>
          </div>
          <div id="collapseFour" class="collapse" aria-labelledby="headingFour" data-parent="#accordion">
            <div class="card-body">
              That's a tricky one, because as you can see the purple curve goes below the yellow one (it even goes negative!) for a long time, intersecting it only at \(x=200\) (you can verify it by calculating \(n^3-100n^2 = {n^3 \over 2}\) or zooming in the chart
              close to \(x=200\)), but as \(n^3 \gg n^2\), we have a time complexity of \(\Theta(n^3)\).
              <canvas id="complexity4" class="chartjs" width="undefined" height="undefined"></canvas>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="card-header" data-toggle="collapse" data-target="#collapseFive" id="headingFive">
            <h5 class="mb-0">
              <button class="btn btn-link collapsed">
                <div class="formula">\({2n^2 \over 3n^2-1}\)</div>
              </button>
            </h5>
          </div>
          <div id="collapseFive" class="collapse" aria-labelledby="headingFive" data-parent="#accordion">
            <div class="card-body">
              Maybe you can not see the complexity of this formula right in time, but if you remember from your Calculus classes, you will realize that a limit solves it with mastery, as \(\lim_{x\to\infty} {2n^2 \over 3n^2-1} = {2 \over 3}\). In conclusion, our time
              complexity is constant, or \(\Theta(1)\).
              <canvas id="complexity5" class="chartjs" width="undefined" height="undefined"></canvas>
            </div>
          </div>
        </div>
        <div class="card">
          <div class="card-header" data-toggle="collapse" data-target="#collapseSix" id="headingSix">
            <h5 class="mb-0">
              <button class="btn btn-link collapsed">
                <div class="formula">\(10n \log (2n)\)</div>
              </button>
            </h5>
          </div>
          <div id="collapseSix" class="collapse" aria-labelledby="headingSix" data-parent="#accordion">
            <div class="card-body">
              We need to go further with this chart to see something. Trying to see that it has a timple complexity of \(\Theta(n \log n)\) is a bit hard with a chart, as \(\log n\) is REALLY slow, but with a chart going until 50000 we are able to see something. With
              math, we can see that the green-ish line overcomes the purple one at \(x=1024\), but we are unable to see any difference in the chart until something around \(x=10000\), as \(\log\) grows really slowly.
              <canvas id="complexity6" class="chartjs" width="undefined" height="undefined"></canvas>
            </div>
          </div>
        </div>
      </div>

      <h2 id="subtitle-1">Analyzing sorting algorithms üîÉ</h2>
      <p>In this first lab, we will analyze the basic sorting algorithms: BubbleSort, InsertionSort (with its variance) and ShellSort (with different sequences). All the analysis will be made sorting arrays of unsigned integers, using two languages: C (which
        will have a better performance, in most cases) and JavaScript. We will analyze the time spent to sort the array, as well as the changes/swaps needed to do it. For Sorted and Reversed arrays, the program was run only once, but to generate the Random
        data, each size was run 12 times or 2 minutes, whichever took less time, so that we were able to make something like an average, to avoid samples where we got a more or less ordered random arrangement of values in the array. Another point about
        the random array generation, is that it allocation + filling-the-array-with-values time was taken in consideration in the time measure (for sake of comparison it doesn't matter as every sample has that extra "linear" time). <br/><b>Disclaimer:</b>        Some weird values can be seen in the sorted array examples, partially because we just ran it once, and it could have been blocked by some OS interruption, taking longer than it would be expected, looking for us like a strange curve in the chart.</p>
      <br/>

      <h3>Bubble Sort üîÅ</h3>
      <p>With a time complexity of \(\Theta(n^2)\), this algorithm is probably one of the worsts algorithms to sort something (if you want something worst, why don't you take a look at <a href="https://en.wikipedia.org/wiki/Bogosort">BogoSort</a> and
        <a href="https://pt.wikipedia.org/wiki/Sleep_sort">SleepSort üí§(in Portuguese)</a>?), as it takes a LOT of time to organize an array of values.</p>
      <p>It was used arrays varying from \(2^1\) until \(2^{18}\) to generate the data below. The left y-axis shows the changes and the right one shows the time. As a reminder, the sorted charts may be a bit wrong in the time dataset, as explained before
        in this article (tldr: OS interruptions can cause this).</p>
      <p>The code used for it can be seen below, followe by the charts showing the data.</p>

      <!-- BubbleSort code -->
      <pre><code>long long int bubbleSort(int *data, int size)
      {
          long long int changes = 0;
          int ordered = size-1, lastOrdered = 1, changed, i, temp;

          do
          {
              changed = 0;
              for(i=0; i&lt;ordered; i++)
              {
                  if(array[i] &gt; array[i+1])
                  {
                      temp = array[i];
                      array[i] = array[i+1];
                      array[i+1] = temp;

                      lastOrdered = i;
                      changed = 1;
                      changes++;
                  }
              }
              ordered = lastOrdered;
          }
          while(changed);

          return changes;
      }</code></pre>
      <div class='canvas-inside'>
        <canvas id="bubble-1" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="bubble-2" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="bubble-3" class="chartjs" width="640" height="400"></canvas>
      </div>
      <p>Some information we can retrieve from this charts are that BubbleSort has best case complexity of \(\Theta(n)\) as it will only run through the array once, and stop, this is why it only makes 0 changes, and has such a small running time (0?). Reversed
        case really show us why he has such an assymptotic curve, going from 0.82s in the size 16384 to incredible 177s when in size 262144 (16x bigger size, 256x bigger time, as we would expect with a \(\Theta(n^2)\) complexity). To have some fun, we
        plotted our random bubble sort chart in logarithmic scale, and as we can see, the changes grow almost perfectly logarithmically while the time doesn't (really don't know exactly why).</p>
      <br/>

      <h3>Insertion Sort ‚§µÔ∏è</h3>
      <p>Let's move on to another simple sorting algorithm which we all learned in our 1st year at CS course. It also has a time complexity of \(\Theta(n^2)\), but we will be able to see some evolution, comparing to bubble Sort.</p>
      <p>For this charts we also used arrays varying from \(2^1\) until \(2^{18}\) to generate the data below. All bla-bla-blas spoken about the BubbleSort are also valid here.</p>
      <p>The code used for it can be seen below, followed by the charts showing the data.</p>

      <!-- BubbleSort code -->
      <pre><code>long long int insertionSort(int* C, int n)
      {
          long long int changes = 0;
          int i, j, key;

          for(j=1; j&lt;n; j++)
          {
              key = C[j];
              i = j-1;
              while(i &gt;= 0 && C[i] &gt; key)
              {
                  C[i+1] = C[i];
                  i--;
                  changes++;
              }
              C[i+1] = key;
          }

          return changes;
      }</code></pre>
      <div class='canvas-inside'>
        <canvas id="insertion-1" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="insertion-2" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="insertion-3" class="chartjs" width="640" height="400"></canvas>
      </div>
      <p>Hello again, bro! How've you been? Long time, no see. I really like the Selection Sort idea, it's really a pity that it's a worst-case complexity of \(\Theta(n^2)\). üòû. Reversed chart shows us that it makes exactly the same changes as the BubbleSort
        in reverse order, although it took less time, so point to Insertion ‚ú®. In random data, it also runs A LOT faster than Bubble sort (in this sample casa, almost 3X faster). So, although both have an average-case time complexity of \(\Theta(n^2)\),
        it will only be the same assymptotically, as in "small" samples Insertion can be really faster. </p>
      <br/>

      <h3>Binary Insertion Sort ‚§µÔ∏è</h3>
      <p>Now we will have a kind of evolution of the Insertion Sort Algorithm. As we are searching the place to insert our new number, in an already ordered arrray, it is pretty easy to think about a bynary search to find the exact place. So, let's see how
        the thing goes.</p>
      <p>Again, arrays size varying from \(2^1\) until \(2^{18}\) to generate the data below. Could have used a bigger data sample, because as you wil see, this is a bit faster than the last two, but to keep the comparison between them, we used the same
        data sample.
      </p>
      <p>The code used for it, as well as the code used in the binary search, can be seen below, followed by the charts showing the data.</p>

      <!-- BubbleSort code -->
      <pre><code>int binarySearch(int* data, int inf, int sup, int key)
      {
          int half;
          if (inf == sup)
              return inf;
          half = inf + ((sup-inf)/2);
          if (key > data[half])
              return binarySearch(data, half+1, sup, key);
          else if (key < data [half])
              return binarySearch(data, inf, half, key);
          return half;
      }

      long long int binaryInsertionSort(int *C, int n)
      {
          long long int changes = 0;
          int i, j, key, posicao;

          for(int j=1; j &lt; n; j++)
          {
              key = C[j];
              i = j-1;
              posicao = binarySearch(C, 0, j, key);
              while(i>=posicao)
              {
                  C[i+1] = C[i];
                  i--;
                  changes++;
              }

              C[posicao] = key;
          }

          return changes;
      }</code></pre>
      <div class='canvas-inside'>
        <canvas id="binary-1" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="binary-2" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="binary-3" class="chartjs" width="640" height="400"></canvas>
      </div>
      <p>As you can see, the changes occur the exactly same times both in Normal and Binary Insertion. The great advantage comes when we don't need to compare as many times as we would compare in a normal Insertion Sort, because we can find the place we
        must inert ourselves in \(\log n\) time, giving us something around 30% of time, although having an average-case time complexity of \(\Theta(n^2)\), exactly the same as Bubble and Insertion Sort.</p>
      <br/>

      <h3>Shell Sort ‚§µÔ∏è</h3>
      <p>Let's start talking about the Shell, thinking about the Insertion. What is it really good about? Sorting ALMOST sortered stuff! And that's what the Shell sort abuses of, making the array each time more "sorted", making it faster to get fully sorted.
        It uses something called <span class="formula" sequences></span> to order different pieces of the array at the same time (you can learn more about this <a href="https://en.wikipedia.org/wiki/Shellsort">here</a>. Here we used three different sequences,
        as follow:</p>
      <ul>
        <li>Shell Sequence (1, 2, 4, 8, 16, 32, ...)</li>
        <li>Knuth Sequence (1, 4, 13, 40, 121, 364, ...)</li>
        <li>Tokuda Sequence (1, 4, 9, 20, 46, 103, ...)</li>
      </ul>
      <p>It is expected that each sequence makes the shell sort faster (although, as we will see, the last two have just a small difference), as they tend do decrease their time-complexity, with the Tokuda Sequence having a time-complexity not yet calculated,
        but probably better than the Knuth one (\(O(N^(1+\sqrt{{8\ln(5/2) \over \ln(N)}}))\)) - too hard I know.</p>
      <p>This time, arrays size will vary from \(2^1\) until \(2^{28}\) to generate the data below, to all the sequences.</p>
      <p>The code used for it can be seen below, followed by the NINE charts (three for each sequence), showing the data. The gap sequence generation will be omitted for sake of brevity.</p>

      <!-- BubbleSort code -->
      <pre><code>long long int shellSort(int *C, int n, int typeSequence)
      {
          int numElems;
          int* sequence = generateGapSequence(n,typeSequence,&numElems); //Omitted for brevity

          long long int changes = 0;
          int i, h, f;

          for(i=numElems-1; i>=0; i--)
          {
              h = sequence[i];
              for(f=0; f&lt;h; f++)
              {
                  changes += insertionShellSort(C,n,h,f); //The same code from before, with some '1' values changed for h or f, accordingly
              }
          }

          free(sequence);

          return changes;
      }</code></pre>
      <div class='canvas-inside'>
        <canvas id="shell0-1" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="shell0-2" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="shell0-3" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="shell1-1" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="shell1-2" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="shell1-3" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="shell2-1" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="shell2-2" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="shell2-3" class="chartjs" width="640" height="400"></canvas>
      </div>
      <p>Wow, we have a lot of data here! As you can see, it is pretty BAD at sorting already sorted arrays in comparison to the others sorting algorithms. That would be easily solved by adding a check to see if it is already sorted (although, it wouldn't
        solve "almost sorted" arrays" long time). A HUGE improvement can be observed in the last two, as they only take roughly 0.1s to sort the same thing Insertion took 43 seconds!!!!11!.</p>
      <p>Weirdly enough, Knuth and Tokuda sequences got pretty close, not exactly saying which one is better, which is plausible, as Tokuda one doesnt have a time-complexity well-established. Anyway, we will have some comparisons to see that difference better
        in some charts below.).</p>
      <br/>

      <h3>Conclusion and + Charts üëç</h3>
      <p>This is over for today! Hope you enjoyed the article, and that it gave you some insights another ones didn't gave you, as it took a lot of time from me. Wait for similar stuff for the other sorting algorithms! Take a look in the below charts, with
        some directly comparisons between the different sorting algorithms, remembering that the 3 \(\Theta(n^2)\) algorithms only have data until size \(2^{18}\), while the 3 Shell ones go up until \(2^{28}\).</p>
      <div class='canvas-inside'>
        <canvas id="sorted" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="reversed" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="random" class="chartjs" width="640" height="400"></canvas>
      </div>
      <div class='canvas-inside'>
        <canvas id="shell-random" class="chartjs" width="640" height="400"></canvas>
      </div>

      <br/><br/>
      <h3>Playground ‚è≥</h3>
      <p>This algorithms were also "translated" to JavaScript which can be acessed through the API below. I wish this was non-blocking requests, so that you could make more than one request and receive all of them as soon as they finish ther computation,
        but I couldn't, so be careful with some big numbers, as it will execute all the queries in order, until you restart the server. Make some exploration and discover what you can do with it. You can see that running it in assyncronous Javascript
        makes it REALLY faster when using Bubble or Insertion sort, although it makes Shell algorithm slower (we can't process a lot of things at the same time, as we must make all the different sequence values of \(h\) in order).Hope you enjoyed, and
        see you next time!</p>
      <div class="card">
        <div class="card-body">
          <form>
            <div class="form-group">
              <label for="sortingAlgorithm">Sorting Algorithm</label>
              <select class="form-control" id="sortingAlgorithm">
                <option value='bubble'>Bubble Sort</option>
                <option value='insertion'>Insertion Sort</option>
                <option value='binaryInsertion'>Binary Insertion Sort</option>
                <option value='shell/0'>Shell Sort - Shell Sequence</option>
                <option value='shell/1'>Shell Sort - Knuth Sequence</option>
                <option value='shell/2'>Shell Sort - Tokuda Sequence</option>
               </select>
            </div>
            <div class="form-group">
              <label for="arrayType">Array Type</label>
              <select class="form-control" id="arrayType">
                <option value='sorted'>Sorted Array</option>
                <option value='reversed'>Reversed Array</option>
                <option value='random'>Random Array</option>
                <option value='custom' selected="selected">Custom Array</option>
               </select>
            </div>
            <div id="arraySizeDiv" class="form-group" style="display: none">
              <label for="arraySize">Array Size</label>
              <input type="text" class="form-control" id="arraySize">
              <small id="arraySizeHelp" class="form-text text-muted">Insert a valid positive number</small>
            </div>
            <div id="customFieldDiv" class="form-group">
              <label id="labelCustomField" for="customField">Custom field</label>
              <input type="text" class="form-control" id="customField" placeholder="1 2 3 4">
              <small id="customFieldHelp" class="form-text text-muted">Insert numbers with a space between them</small>
            </div>
            <button id="submitButton" type="submit" class="btn btn-primary">Go</button>
          </form>
          <hr/>
          <table class="table table-hover">
            <thead>
              <tr>
                <th scope="col">#</th>
                <th scope="col">Sorting Algorithm</th>
                <th scope="col">Array Type</th>
                <th scope="col">Array Size</th>
                <th scope="col">Time</th>
                <th scope="col">Changes</th>
              </tr>
            </thead>
            <tbody id="playgroundTable">
              <tr id="information">
                <td></td>
                <td colspan="5">Nothing here yet, you should make requests there, so that I can show u smth ‚¨ÜÔ∏è</td>
              </tr>
            </tbody>
          </table>
          <button id="resetTable" class="btn btn-primary float-right">Reset Table</button>
        </div>
      </div>

    </article>
    <footer><a href="www.inf.ufrgs.br/~rbaudibert">Website</a> | <a href="https://github.com/rafaeelaudibert">GitHub</a> | <a href="https://www.facebook.com/rafaeelaudibert">Facebook</a>
    </footer>


    <script src="main.js"></script>
    <script src="highlight.pack.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
      const capitalize = str => str.charAt(0).toUpperCase() + str.slice(1);


      $('#submitButton').click(e => {
        e.preventDefault();

        const sortingAlgorithm = $('#sortingAlgorithm')[0].value;
        const arrayType = $('#arrayType')[0].value;
        const arraySize = parseInt($('#arraySize')[0].value);
        const customValue = $('#customField')[0].value.split(' ').map(parseFloat);

        if (arrayType == 'custom' && !isNaN(customValue[0])) {
          $.ajax(`${arrayType}/${sortingAlgorithm}/${customValue}`).then(data => {
            $('#information').hide(0);
            const table = $('#playgroundTable');
            const {
              changes,
              ordered,
              time
            } = data;
            table.append($('<tr></tr>').append($('<td></td>').append(table[0].children.length)).append($('<td></td>').append(capitalize(sortingAlgorithm))).append($('<td></td>').append(capitalize(arrayType))).append($('<td></td>')
              .append(
                customValue.length)).append($(
              '<td></td>').append(time)).append($(
              '<td></td>').append(
              changes)));
          });

        } else if (arrayType != 'custom' && !isNaN(arraySize)) {
          $.ajax(`${arrayType}/${sortingAlgorithm}/${arraySize}`).then(data => {
            $('#information').hide(0);
            const table = $('#playgroundTable');
            const {
              changes,
              ordered,
              time
            } = data;
            table.append($('<tr></tr>').append($('<td></td>').append(table[0].children.length)).append($('<td></td>').append(capitalize(sortingAlgorithm))).append($('<td></td>').append(capitalize(arrayType))).append($('<td></td>')
              .append(
                arraySize)).append($(
              '<td></td>').append(time)).append($(
              '<td></td>').append(
              changes)));
          });
        } else {
          $('#information').hide(0);
          const table = $('#playgroundTable');
          table.append($('<tr></tr>').append($('<td></td>').append(table[0].children.length)).append($('<td></td>').append(capitalize(sortingAlgorithm))).append($('<td></td>').append(capitalize(arrayType))).append($('<td></td>').append(
            'M√Å REQUISI√á√ÉO')).append($(
            '<td></td>').append('-')).append($(
            '<td></td>').append(
            '-')));
        }
      })

      $('#arrayType').change(e => {
        if (e.target.value == 'custom') {
          $('#customFieldDiv').show(0)
          $('#arraySizeDiv').hide(0)
        } else {
          $('#customFieldDiv').hide(0)
          $('#arraySizeDiv').show(0)
        }
      });

      $('#resetTable').click(e => {
        const table = $('#playgroundTable');
        $('#information').show(0);
        table.children.split(1, table.length - 1);

      })

    </script>
  </body>

</html>
